# User Memory for 

## Personal Information
- **Name**: 
- **Role**: AI Engineer
- **Focus**: Building AI-powered applications

## Development Environment
- **OS**: 
- **Shell**: 
- **Project Location**: `/`
- **Python**: 3.11+
- **Node.js**: 
- **GPU**: Available for training

## Tech Stack Preferences
### AI/ML Frameworks
- **LLMs**: OpenAI API, Anthropic Claude, Local models (Ollama)
- **Frameworks**: LangChain, LlamaIndex, Semantic Kernel
- **ML Libraries**: PyTorch, Transformers, scikit-learn
- **Vector DBs**: Qdrant, Pinecone, Weaviate, pgvector

### Development Stack
- **Backend**: FastAPI (Python), Node.js for integrations
- **Frontend**: Vue 3 or React for AI interfaces
- **Databases**: PostgreSQL with pgvector, Redis for caching
- **Message Queue**: RabbitMQ, Celery for long-running tasks

### AI Tools & Services
- **Embeddings**: OpenAI, Cohere, local models
- **Speech**: Whisper, ElevenLabs
- **Vision**: GPT-4 Vision, CLIP
- **Workflows**: n8n, Temporal
- **Monitoring**: Weights & Biases, MLflow

## Work Style & Preferences
- **Approach**: Prototype with APIs, optimize with local models
- **RAG Systems**: Build retrieval-augmented generation pipelines
- **Prompt Engineering**: Iterative refinement, version control
- **Evaluation**: Systematic testing of AI outputs
- **Cost Optimization**: Token usage tracking, caching strategies

## Claude Interaction Preferences
- **Style**: Focus on AI integration patterns
- **Code Examples**: Complete AI pipelines
- **Architecture**: Scalable AI system design
- **Best Practices**: Error handling, fallbacks, rate limiting
- **Testing**: AI output validation strategies

## Project Approach
- Start with proof of concept
- Implement RAG for domain-specific knowledge
- Design for model swappability
- Monitor performance and costs
- Build evaluation frameworks
- Document prompts and chains

## AI-Specific Patterns
- Prompt templates with variables
- Conversation memory management
- Document chunking strategies
- Embedding optimization
- Semantic search implementation
- Multi-agent workflows
- Tool/Function calling patterns
- Streaming responses
- Context window management

## Common Integrations
- **MCP Servers**: For tool integration
- **API Gateways**: For rate limiting
- **Observability**: OpenTelemetry for tracing
- **Feature Stores**: For ML features
- **Model Registry**: For version management